// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package nodetainted

import (
	"github.com/test-network-function/cnf-certification-test/internal/clientsholder"
	"sync"
)

// Ensure, that TaintedFuncsMock does implement TaintedFuncs.
// If this is not the case, regenerate this file with moq.
var _ TaintedFuncs = &TaintedFuncsMock{}

// TaintedFuncsMock is a mock implementation of TaintedFuncs.
//
// 	func TestSomethingThatUsesTaintedFuncs(t *testing.T) {
//
// 		// make and configure a mocked TaintedFuncs
// 		mockedTaintedFuncs := &TaintedFuncsMock{
// 			GetKernelTaintInfoFunc: func(ctx clientsholder.Context) (string, error) {
// 				panic("mock out the GetKernelTaintInfo method")
// 			},
// 			GetModulesFromNodeFunc: func(ctx clientsholder.Context) []string {
// 				panic("mock out the GetModulesFromNode method")
// 			},
// 			GetOutOfTreeModulesFunc: func(modules []string, ctx clientsholder.Context) []string {
// 				panic("mock out the GetOutOfTreeModules method")
// 			},
// 			ModuleInTreeFunc: func(moduleName string, ctx clientsholder.Context) bool {
// 				panic("mock out the ModuleInTree method")
// 			},
// 			runCommandFunc: func(ctx clientsholder.Context, cmd string) (string, error) {
// 				panic("mock out the runCommand method")
// 			},
// 		}
//
// 		// use mockedTaintedFuncs in code that requires TaintedFuncs
// 		// and then make assertions.
//
// 	}
type TaintedFuncsMock struct {
	// GetKernelTaintInfoFunc mocks the GetKernelTaintInfo method.
	GetKernelTaintInfoFunc func(ctx clientsholder.Context) (string, error)

	// GetModulesFromNodeFunc mocks the GetModulesFromNode method.
	GetModulesFromNodeFunc func(ctx clientsholder.Context) []string

	// GetOutOfTreeModulesFunc mocks the GetOutOfTreeModules method.
	GetOutOfTreeModulesFunc func(modules []string, ctx clientsholder.Context) []string

	// ModuleInTreeFunc mocks the ModuleInTree method.
	ModuleInTreeFunc func(moduleName string, ctx clientsholder.Context) bool

	// runCommandFunc mocks the runCommand method.
	runCommandFunc func(ctx clientsholder.Context, cmd string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetKernelTaintInfo holds details about calls to the GetKernelTaintInfo method.
		GetKernelTaintInfo []struct {
			// Ctx is the ctx argument value.
			Ctx clientsholder.Context
		}
		// GetModulesFromNode holds details about calls to the GetModulesFromNode method.
		GetModulesFromNode []struct {
			// Ctx is the ctx argument value.
			Ctx clientsholder.Context
		}
		// GetOutOfTreeModules holds details about calls to the GetOutOfTreeModules method.
		GetOutOfTreeModules []struct {
			// Modules is the modules argument value.
			Modules []string
			// Ctx is the ctx argument value.
			Ctx clientsholder.Context
		}
		// ModuleInTree holds details about calls to the ModuleInTree method.
		ModuleInTree []struct {
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Ctx is the ctx argument value.
			Ctx clientsholder.Context
		}
		// runCommand holds details about calls to the runCommand method.
		runCommand []struct {
			// Ctx is the ctx argument value.
			Ctx clientsholder.Context
			// Cmd is the cmd argument value.
			Cmd string
		}
	}
	lockGetKernelTaintInfo  sync.RWMutex
	lockGetModulesFromNode  sync.RWMutex
	lockGetOutOfTreeModules sync.RWMutex
	lockModuleInTree        sync.RWMutex
	lockrunCommand          sync.RWMutex
}

// GetKernelTaintInfo calls GetKernelTaintInfoFunc.
func (mock *TaintedFuncsMock) GetKernelTaintInfo(ctx clientsholder.Context) (string, error) {
	if mock.GetKernelTaintInfoFunc == nil {
		panic("TaintedFuncsMock.GetKernelTaintInfoFunc: method is nil but TaintedFuncs.GetKernelTaintInfo was just called")
	}
	callInfo := struct {
		Ctx clientsholder.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetKernelTaintInfo.Lock()
	mock.calls.GetKernelTaintInfo = append(mock.calls.GetKernelTaintInfo, callInfo)
	mock.lockGetKernelTaintInfo.Unlock()
	return mock.GetKernelTaintInfoFunc(ctx)
}

// GetKernelTaintInfoCalls gets all the calls that were made to GetKernelTaintInfo.
// Check the length with:
//     len(mockedTaintedFuncs.GetKernelTaintInfoCalls())
func (mock *TaintedFuncsMock) GetKernelTaintInfoCalls() []struct {
	Ctx clientsholder.Context
} {
	var calls []struct {
		Ctx clientsholder.Context
	}
	mock.lockGetKernelTaintInfo.RLock()
	calls = mock.calls.GetKernelTaintInfo
	mock.lockGetKernelTaintInfo.RUnlock()
	return calls
}

// GetModulesFromNode calls GetModulesFromNodeFunc.
func (mock *TaintedFuncsMock) GetModulesFromNode(ctx clientsholder.Context) []string {
	if mock.GetModulesFromNodeFunc == nil {
		panic("TaintedFuncsMock.GetModulesFromNodeFunc: method is nil but TaintedFuncs.GetModulesFromNode was just called")
	}
	callInfo := struct {
		Ctx clientsholder.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetModulesFromNode.Lock()
	mock.calls.GetModulesFromNode = append(mock.calls.GetModulesFromNode, callInfo)
	mock.lockGetModulesFromNode.Unlock()
	return mock.GetModulesFromNodeFunc(ctx)
}

// GetModulesFromNodeCalls gets all the calls that were made to GetModulesFromNode.
// Check the length with:
//     len(mockedTaintedFuncs.GetModulesFromNodeCalls())
func (mock *TaintedFuncsMock) GetModulesFromNodeCalls() []struct {
	Ctx clientsholder.Context
} {
	var calls []struct {
		Ctx clientsholder.Context
	}
	mock.lockGetModulesFromNode.RLock()
	calls = mock.calls.GetModulesFromNode
	mock.lockGetModulesFromNode.RUnlock()
	return calls
}

// GetOutOfTreeModules calls GetOutOfTreeModulesFunc.
func (mock *TaintedFuncsMock) GetOutOfTreeModules(modules []string, ctx clientsholder.Context) []string {
	if mock.GetOutOfTreeModulesFunc == nil {
		panic("TaintedFuncsMock.GetOutOfTreeModulesFunc: method is nil but TaintedFuncs.GetOutOfTreeModules was just called")
	}
	callInfo := struct {
		Modules []string
		Ctx     clientsholder.Context
	}{
		Modules: modules,
		Ctx:     ctx,
	}
	mock.lockGetOutOfTreeModules.Lock()
	mock.calls.GetOutOfTreeModules = append(mock.calls.GetOutOfTreeModules, callInfo)
	mock.lockGetOutOfTreeModules.Unlock()
	return mock.GetOutOfTreeModulesFunc(modules, ctx)
}

// GetOutOfTreeModulesCalls gets all the calls that were made to GetOutOfTreeModules.
// Check the length with:
//     len(mockedTaintedFuncs.GetOutOfTreeModulesCalls())
func (mock *TaintedFuncsMock) GetOutOfTreeModulesCalls() []struct {
	Modules []string
	Ctx     clientsholder.Context
} {
	var calls []struct {
		Modules []string
		Ctx     clientsholder.Context
	}
	mock.lockGetOutOfTreeModules.RLock()
	calls = mock.calls.GetOutOfTreeModules
	mock.lockGetOutOfTreeModules.RUnlock()
	return calls
}

// ModuleInTree calls ModuleInTreeFunc.
func (mock *TaintedFuncsMock) ModuleInTree(moduleName string, ctx clientsholder.Context) bool {
	if mock.ModuleInTreeFunc == nil {
		panic("TaintedFuncsMock.ModuleInTreeFunc: method is nil but TaintedFuncs.ModuleInTree was just called")
	}
	callInfo := struct {
		ModuleName string
		Ctx        clientsholder.Context
	}{
		ModuleName: moduleName,
		Ctx:        ctx,
	}
	mock.lockModuleInTree.Lock()
	mock.calls.ModuleInTree = append(mock.calls.ModuleInTree, callInfo)
	mock.lockModuleInTree.Unlock()
	return mock.ModuleInTreeFunc(moduleName, ctx)
}

// ModuleInTreeCalls gets all the calls that were made to ModuleInTree.
// Check the length with:
//     len(mockedTaintedFuncs.ModuleInTreeCalls())
func (mock *TaintedFuncsMock) ModuleInTreeCalls() []struct {
	ModuleName string
	Ctx        clientsholder.Context
} {
	var calls []struct {
		ModuleName string
		Ctx        clientsholder.Context
	}
	mock.lockModuleInTree.RLock()
	calls = mock.calls.ModuleInTree
	mock.lockModuleInTree.RUnlock()
	return calls
}

// runCommand calls runCommandFunc.
func (mock *TaintedFuncsMock) runCommand(ctx clientsholder.Context, cmd string) (string, error) {
	if mock.runCommandFunc == nil {
		panic("TaintedFuncsMock.runCommandFunc: method is nil but TaintedFuncs.runCommand was just called")
	}
	callInfo := struct {
		Ctx clientsholder.Context
		Cmd string
	}{
		Ctx: ctx,
		Cmd: cmd,
	}
	mock.lockrunCommand.Lock()
	mock.calls.runCommand = append(mock.calls.runCommand, callInfo)
	mock.lockrunCommand.Unlock()
	return mock.runCommandFunc(ctx, cmd)
}

// runCommandCalls gets all the calls that were made to runCommand.
// Check the length with:
//     len(mockedTaintedFuncs.runCommandCalls())
func (mock *TaintedFuncsMock) runCommandCalls() []struct {
	Ctx clientsholder.Context
	Cmd string
} {
	var calls []struct {
		Ctx clientsholder.Context
		Cmd string
	}
	mock.lockrunCommand.RLock()
	calls = mock.calls.runCommand
	mock.lockrunCommand.RUnlock()
	return calls
}
