---
name: Update Nightlies Dashboard

'on':
  schedule:
    # Run every hour during business hours (9 AM - 6 PM UTC)
    - cron: '0 9-18 * * 1-5'
  workflow_dispatch:  # Allow manual triggering
  push:
    branches: [main]
    paths:
      - 'docs/nightlies/**'
      - '.github/workflows/update-dashboard.yml'

permissions:
  contents: write
  actions: read

jobs:
  update-dashboard:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm init -y
          npm install @octokit/rest

      - name: Generate Dashboard Data
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cat > package.json << 'EOF'
          {
            "type": "module"
          }
          EOF
          
          cat > generate-dashboard.js << 'EOF'
          import { Octokit } from '@octokit/rest';
          import fs from 'fs';
          import path from 'path';
          import { fileURLToPath } from 'url';
          
          const __filename = fileURLToPath(import.meta.url);
          const __dirname = path.dirname(__filename);

          const octokit = new Octokit({
            auth: process.env.GITHUB_TOKEN
          });

          const REPO_OWNER = 'redhat-best-practices-for-k8s';
          const REPO_NAME = 'certsuite';
          const DAYS_BACK = 3;

                   // Workflows to monitor (from the rekick script)
           const WORKFLOWS_TO_MONITOR = [
             "QE OCP 4.14 Testing",
             "QE OCP 4.15 Testing",
             "QE OCP 4.16 Testing",
             "QE OCP 4.17 Testing",
             "QE OCP 4.18 Testing",
             "QE OCP 4.19 Testing",
             "QE OCP 4.14 Intrusive Testing",
             "QE OCP 4.15 Intrusive Testing",
             "QE OCP 4.16 Intrusive Testing",
             "QE OCP 4.17 Intrusive Testing",
             "QE OCP 4.18 Intrusive Testing",
             "QE OCP 4.19 Intrusive Testing",
             "qe-ocp-hosted.yml"
           ];

          async function fetchWorkflowData() {
            console.log('Fetching workflow data...');

            // Calculate cutoff date
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - DAYS_BACK);

            try {
              // Get all workflows
              const { data: workflows } = await octokit.rest.actions.listRepoWorkflows({
                owner: REPO_OWNER,
                repo: REPO_NAME
              });

              const workflowResults = [];

              for (const workflowName of WORKFLOWS_TO_MONITOR) {
                console.log(`Processing workflow: ${workflowName}`);

                // Find the workflow by name or filename
                const workflow = workflows.workflows.find(w =>
                  w.name === workflowName ||
                  w.path.includes(workflowName) ||
                  w.path.includes(workflowName.toLowerCase().replace(/\s+/g, '-'))
                );

                if (!workflow) {
                  console.warn(`Workflow not found: ${workflowName}`);
                  workflowResults.push({
                    workflow: workflowName,
                    runs: [],
                    id: null,
                    error: 'Workflow not found'
                  });
                  continue;
                }

                try {
                  // Fetch recent runs for this workflow
                  const { data: runsData } = await octokit.rest.actions.listWorkflowRuns({
                    owner: REPO_OWNER,
                    repo: REPO_NAME,
                    workflow_id: workflow.id,
                    per_page: 30
                  });

                  // Filter runs from last N days
                  const recentRuns = runsData.workflow_runs.filter(run =>
                    new Date(run.created_at) >= cutoffDate
                  );

                  workflowResults.push({
                    workflow: workflowName,
                    runs: recentRuns,
                    id: workflow.id,
                    path: workflow.path
                  });

                } catch (error) {
                  console.error(`Error fetching runs for ${workflowName}:`, error.message);
                  workflowResults.push({
                    workflow: workflowName,
                    runs: [],
                    id: workflow.id,
                    error: error.message
                  });
                }
              }

              return workflowResults;

            } catch (error) {
              console.error('Error fetching workflows:', error);
              throw error;
            }
          }

          async function updateDashboardHTML(workflowResults) {
            console.log('Updating dashboard HTML...');

            // Calculate summary stats
            let totalRuns = 0;
            let successfulRuns = 0;
            let failedRuns = 0;
            let pendingRuns = 0;
            let totalDurationMs = 0;
            let completedRuns = 0;

            workflowResults.forEach(result => {
              result.runs.forEach(run => {
                totalRuns++;
                switch (run.conclusion) {
                  case 'success':
                    successfulRuns++;
                    break;
                  case 'failure':
                  case 'timed_out':
                    failedRuns++;
                    break;
                  default:
                    pendingRuns++;
                }

                // Calculate duration for completed runs
                if (run.conclusion && run.created_at && run.updated_at) {
                  const duration = new Date(run.updated_at) - new Date(run.created_at);
                  totalDurationMs += duration;
                  completedRuns++;
                }
              });
            });

            const successRate = totalRuns > 0 ? Math.round((successfulRuns / totalRuns) * 100) : 0;

            // Helper function to format duration
            function formatDuration(durationMs) {
              const hours = Math.floor(durationMs / (1000 * 60 * 60));
              const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));

              if (hours > 0) {
                return hours + 'h' + (minutes > 0 ? ' ' + minutes + 'm' : '');
              } else {
                return minutes + 'm';
              }
            }

            const avgRuntime = completedRuns > 0 ? formatDuration(totalDurationMs / completedRuns) : '0h';
            const lastUpdated = new Date().toISOString();

            // Read the template HTML
            const templatePath = path.join(__dirname, 'docs/nightlies/index.html');
            let html = fs.readFileSync(templatePath, 'utf8');

            // Replace the JavaScript data loading with pre-populated data
            const dataScript = `
              <script>
                // Pre-generated data from GitHub Actions
                const WORKFLOW_DATA = ${JSON.stringify(workflowResults, null, 2)};
                const SUMMARY_STATS = {
                  totalRuns: ${totalRuns},
                  successfulRuns: ${successfulRuns},
                  failedRuns: ${failedRuns},
                  pendingRuns: ${pendingRuns},
                  successRate: ${successRate},
                  avgRuntime: '${avgRuntime}'
                };
                const LAST_UPDATED = '${lastUpdated}';

                // Helper functions (same as before)
                function getStatusClass(conclusion) {
                  switch (conclusion) {
                    case 'success': return 'success';
                    case 'failure':
                    case 'timed_out': return 'failure';
                    default: return 'pending';
                  }
                }

                function formatDuration(durationMs) {
                  const hours = Math.floor(durationMs / (1000 * 60 * 60));
                  const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));

                  if (hours > 0) {
                    return hours + 'h ' + minutes + 'm';
                  } else {
                    return minutes + 'm';
                  }
                }

                function getTimeAgo(date) {
                  const now = new Date();
                  const diffMs = now - new Date(date);
                  const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                  const diffDays = Math.floor(diffHours / 24);

                  if (diffDays > 0) {
                    return diffDays + ' day' + (diffDays > 1 ? 's' : '') + ' ago';
                  } else if (diffHours > 0) {
                    return diffHours + ' hour' + (diffHours > 1 ? 's' : '') + ' ago';
                  } else {
                    const diffMinutes = Math.floor(diffMs / (1000 * 60));
                    return diffMinutes + ' minute' + (diffMinutes > 1 ? 's' : '') + ' ago';
                  }
                }

                // Load pre-generated data instead of fetching from API
                document.addEventListener('DOMContentLoaded', function() {
                  // Hide loading, show content
                  document.getElementById('loading').style.display = 'none';
                  document.getElementById('workflows').style.display = 'grid';

                  // Generate summary
                  document.getElementById('summary').innerHTML = \`
                    <div class="card success">
                      <h3>Success Rate</h3>
                      <div class="value">\${SUMMARY_STATS.successRate}%</div>
                      <div>\${SUMMARY_STATS.successfulRuns}/\${SUMMARY_STATS.totalRuns} runs</div>
                    </div>
                    <div class="card failure">
                      <h3>Failed Runs</h3>
                      <div class="value">\${SUMMARY_STATS.failedRuns}</div>
                      <div>Last 3 days</div>
                    </div>
                    <div class="card pending">
                      <h3>Active Workflows</h3>
                      <div class="value">\${WORKFLOW_DATA.length}</div>
                      <div>Being monitored</div>
                    </div>
                    <div class="card">
                      <h3>Avg Runtime</h3>
                      <div class="value">\${SUMMARY_STATS.avgRuntime}</div>
                      <div>Completed runs</div>
                    </div>
                  \`;

                  // Helper function for formatting duration in the generated JS
                  function formatDurationInJS(durationMs) {
                    const hours = Math.floor(durationMs / (1000 * 60 * 60));
                    const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));

                    if (hours > 0) {
                      return hours + 'h ' + minutes + 'm';
                    } else {
                      return minutes + 'm';
                    }
                  }

                  // Generate workflow cards
                  const workflowsHtml = WORKFLOW_DATA.map(result => {
                    const runsHtml = result.runs.slice(0, 10).map(run => {
                      const statusClass = getStatusClass(run.conclusion);
                      const runUrl = run.html_url;
                      const timeAgo = getTimeAgo(run.created_at);

                      // Calculate duration
                      let durationText = '';
                      if (run.conclusion && run.created_at && run.updated_at) {
                        const duration = new Date(run.updated_at) - new Date(run.created_at);
                        durationText = ' â€¢ ' + formatDurationInJS(duration) + ' duration';
                      } else if (!run.conclusion && run.created_at) {
                        // For running jobs, show elapsed time
                        const elapsed = new Date() - new Date(run.created_at);
                        durationText = ' â€¢ ' + formatDurationInJS(elapsed) + ' elapsed';
                      }

                      return \`
                        <div class="run-item">
                          <div class="status-badge \${statusClass}"></div>
                          <div class="run-info">
                            <a href="\${runUrl}" class="run-id" target="_blank">
                              #\${run.run_number} - \${run.conclusion || 'running'}
                            </a>
                            <div class="run-time">\${timeAgo}\${durationText}</div>
                          </div>
                        </div>
                      \`;
                    }).join('');

                    const successCount = result.runs.filter(r => r.conclusion === 'success').length;
                    const totalCount = result.runs.length;

                    // Calculate average runtime for this workflow
                    const completedRuns = result.runs.filter(r => r.conclusion && r.created_at && r.updated_at);
                    let avgWorkflowRuntime = '';
                    if (completedRuns.length > 0) {
                      const totalMs = completedRuns.reduce((sum, run) => {
                        return sum + (new Date(run.updated_at) - new Date(run.created_at));
                      }, 0);
                      avgWorkflowRuntime = ' â€¢ avg ' + formatDurationInJS(totalMs / completedRuns.length);
                    }

                    // Generate workflow URL
                    const workflowUrl = result.path ?
                      \`https://github.com/redhat-best-practices-for-k8s/certsuite/actions/workflows/\${result.path.split('/').pop()}\` :
                      \`https://github.com/redhat-best-practices-for-k8s/certsuite/actions\`;

                    return \`
                      <div class="workflow-card">
                        <div class="workflow-header">
                          <div>
                            <a href="\${workflowUrl}" class="workflow-title-link" target="_blank">
                              <div class="workflow-title">\${result.workflow}</div>
                            </a>
                            <div class="workflow-subtitle">
                              \${totalCount} runs in last 3 days
                              (\${successCount} successful)\${avgWorkflowRuntime}
                            </div>
                          </div>
                        </div>
                        <div class="runs-list">
                          \${runsHtml || '<div class="run-item">No recent runs</div>'}
                        </div>
                      </div>
                    \`;
                  }).join('');

                  document.getElementById('workflows').innerHTML = workflowsHtml;

                  // Update last updated time
                  document.getElementById('last-updated').innerHTML =
                    'Last updated: ' + new Date(LAST_UPDATED).toLocaleString();
                });

                function refreshData() {
                  window.location.reload();
                }
              </script>
            `;

            // Add CSS for workflow title links before replacing the script
            const linkCSS = `
            .workflow-title-link {
                text-decoration: none;
                color: inherit;
            }

            .workflow-title-link:hover .workflow-title {
                color: #3b82f6;
                text-decoration: underline;
            }`;

            // Insert the new CSS before the closing </style> tag
            html = html.replace('</style>', linkCSS + '\\n        </style>');

            // Replace the existing script tag with our data script
            html = html.replace(/<script>[\s\S]*?<\/script>/, dataScript);

            return html;
          }

          async function main() {
            try {
              const workflowResults = await fetchWorkflowData();
              const updatedHTML = await updateDashboardHTML(workflowResults);

              // Write the updated HTML back to the template
              const templatePath = path.join(__dirname, 'docs/nightlies/index.html');
              fs.writeFileSync(templatePath, updatedHTML);

              console.log('Dashboard updated successfully!');
              console.log(`Updated at: ${new Date().toISOString()}`);

              // Also save the raw data for debugging
              fs.writeFileSync(
                path.join(__dirname, 'docs/nightlies/workflow-data.json'),
                JSON.stringify(workflowResults, null, 2)
              );

            } catch (error) {
              console.error('Error updating dashboard:', error);
              process.exit(1);
            }
          }

          main();
          EOF

            node generate-dashboard.js

      - name: Commit updated dashboard
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add docs/nightlies/index.html docs/nightlies/workflow-data.json
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "ðŸ”„ Update nightlies dashboard [automated]
            
            - Updated workflow data and dashboard HTML
            - Auto-generated by Update Nightlies Dashboard workflow
            - Dashboard will be deployed by doc-publish workflow"
            git push
          fi
