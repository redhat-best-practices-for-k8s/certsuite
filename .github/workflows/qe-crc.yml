# https://developers.redhat.com/content-gateway/rest/mirror/pub/openshift-v4/clients/crc/latest/crc-linux-amd64.tar.xz

name: CRC Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
env:
  REGISTRY: quay.io
  REGISTRY_LOCAL: localhost
  TNF_IMAGE_NAME: testnetworkfunction/cnf-certification-test
  TNF_IMAGE_TAG: unstable
  OCT_IMAGE_NAME: testnetworkfunction/oct
  OCT_IMAGE_TAG: latest
  TNF_CONTAINER_CLIENT: docker
  TNF_NON_INTRUSIVE_ONLY: false
  TNF_ALLOW_PREFLIGHT_INSECURE: false
  TNF_DISABLE_CONFIG_AUTODISCOVER: false
  TNF_CONFIG_DIR: /tmp/tnf/config
  TNF_OUTPUT_DIR: /tmp/tnf/output
  TNF_SRC_URL: 'https://github.com/${{ github.repository }}'
  TESTING_CMD_PARAMS: '-n host -i ${REGISTRY_LOCAL}/${TNF_IMAGE_NAME}:${TNF_IMAGE_TAG} -t ${TNF_CONFIG_DIR} -o ${TNF_OUTPUT_DIR}'
  TNF_SMOKE_TESTS_LOG_LEVEL: trace
  ON_DEMAND_DEBUG_PODS: false
  TERM: xterm-color

jobs:
  smoke-tests:
    name: Run Smoke Tests Against OpenShift Local
    runs-on: ubuntu-latest
    env:
      SHELL: /bin/bash
      KUBECONFIG: '/home/runner/.crc/machines/crc/kubeconfig'
      PFLT_DOCKERCONFIG: '/home/runner/.docker/config'
      OCP_CLUSTER_OVERRIDE: 'true'

    steps:
      - name: Write temporary docker file
        run: |
          mkdir -p /home/runner/.docker
          touch ${PFLT_DOCKERCONFIG}
          echo '{ "auths": {} }' >> ${PFLT_DOCKERCONFIG}
        if: runner.os == 'Linux'

      - name: Set up Go 1.21.6
        uses: actions/setup-go@v4
        with:
          go-version: 1.21.6

      - name: Install required packages for Linux
        run: |
          sudo apt-get update
          sudo apt install qemu-kvm libvirt-daemon libvirt-daemon-system network-manager jq
        if: runner.os == 'Linux'

      - name: Enable KVM group perms
        run: |
          echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
          sudo udevadm control --reload-rules
          sudo udevadm trigger --name-match=kvm
          sudo apt-get update
          sudo apt-get install -y libvirt-clients libvirt-daemon-system libvirt-daemon virtinst bridge-utils qemu qemu-system-x86
          sudo usermod -a -G kvm,libvirt $USER
          sudo adduser `id -un` libvirt

      # Restart docker using /mnt/docker-storage (sdb) instead of /var/lib/docker (sda).
      # This step needs to be done right after the partner repo's bootstrap scripts, as they
      # overwrite the docker's daemon.json.
      - name: Make docker to use /mnt (sdb) for storage
        run: |
          df -h
          lsblk
          sudo mkdir /mnt/docker-storage
          sudo jq '.  +={"data-root" : "/mnt/docker-storage"}' < /etc/docker/daemon.json > /tmp/docker-daemon.json
          sudo cp /tmp/docker-daemon.json /etc/docker/daemon.json
          cat /etc/docker/daemon.json
          sudo systemctl restart docker
          sudo ls -la /mnt/docker-storage

      - name: reload the terminal to load the libvirt group
        run: |
          sudo -E bash -c 'exec su -l '$USER
        if: runner.os == 'Linux'

      - name: Check kvm
        run: |
          sudo apt-get install cpu-checker
          egrep -c '(vmx|svm)' /proc/cpuinfo
          kvm-ok

      - name: Check if user is part of libvirt group
        run: |
          groups
          sudo usermod -a -G libvirt $USER
          groups
        if: runner.os == 'Linux'

      - name: Disable default go problem matcher
        run: echo "::remove-matcher owner=go::"

      - name: Check out code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}

      - name: check if CRC_PULL_SECRET exists
        env: 
          super_secret: ${{ secrets.CRC_PULL_SECRET }}
        if: ${{ env.super_secret == '' }}
        run: 'echo the secret \"CRC_PULL_SECRET\" has not been made; echo please go to \"settings \> secrets \> actions\" to create it'

      - name: Write the pull secret to json file
        run: |
          echo $CRC_PULL_SECRET > temp-ps.json
          cat temp-ps.json
        env:
          CRC_PULL_SECRET: ${{ secrets.CRC_PULL_SECRET }}
        shell: bash

      # Create a OpenShift Local Cluster for testing
      - name: Download the CRC binary (Linux)
        run: |
          wget -O crc-linux-amd64.tar.xz https://developers.redhat.com/content-gateway/file/pub/openshift-v4/clients/crc/2.31.0/crc-linux-amd64.tar.xz
          tar xvf crc-linux-amd64.tar.xz
          sudo mv crc-linux-*/crc /usr/local/bin/
        if: runner.os == 'Linux'

      - name: Set Microshift Preset
        uses: nick-fields/retry@v2
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: crc config set preset microshift

      - name: Set Telemetry
        uses: nick-fields/retry@v2
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: crc config set consent-telemetry yes

      - name: Set Network-Mode User
        uses: nick-fields/retry@v2
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: crc config set network-mode user

      - name: Run CRC Setup
        uses: nick-fields/retry@v2
        with:
          timeout_minutes: 15
          max_attempts: 3
          command: sudo -su $USER crc setup

      - name: Run CRC Start
        uses: nick-fields/retry@v2
        with:
          timeout_minutes: 30
          max_attempts: 3
          command: sudo -su $USER crc start --pull-secret-file temp-ps.json --log-level debug
          on_retry_command: sudo -su $USER crc delete -f

      - name: Wait until node is Ready state
        run: |
          while [[ $(oc get nodes --request-timeout='30s' -o json | jq -r '.items[] | select(.metadata.name=="api.crc.testing") | .status.conditions[] | select(.reason=="KubeletReady") | .status') == "False" ]]; do
            echo "Waiting for node to be in Ready state"
            sleep 5
          done

      - name: Set the adm policy
        run: |
          oc adm policy add-scc-to-user privileged user

      - name: Run oc version
        run: |
          eval $(crc oc-env)
          oc version
          oc get nodes
          oc get pods -A

      - name: Check out `cnf-certification-test-partner`
        uses: actions/checkout@v4
        with:
          repository: test-network-function/cnf-certification-test-partner
          path: cnf-certification-test-partner

      - name: Run 'make install-for-qe'
        run: |
          make install-for-qe
        working-directory: cnf-certification-test-partner

      # Update the CNF containers, helm charts and operators DB

      # - name: Update the CNF DB
      #   run: |
      #     docker pull ${REGISTRY}/${OCT_IMAGE_NAME}:${OCT_IMAGE_TAG}
      #     mkdir -p ${GITHUB_WORKSPACE}/offline-db
      #     docker run -v ${GITHUB_WORKSPACE}/offline-db:/tmp/dump:Z --env OCT_DUMP_ONLY=true ${REGISTRY}/${OCT_IMAGE_NAME}:${OCT_IMAGE_TAG}
      #   shell: bash

      - name: Execute `make build`
        run: make build-cnf-tests

      - name: Run some oc commands
        run: |
          oc get nodes
          oc get pods -A

      # Perform smoke tests.
      - name: 'Test: Run test suites'
        run: TNF_LOG_LEVEL=${TNF_SMOKE_TESTS_LOG_LEVEL} ./run-cnf-suites.sh -l "all"

      - name: Upload smoke test results as an artifact
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: smoke-tests
          path: |
            cnf-certification-test/*.xml
            cnf-certification-test/claim.json
            cnf-certification-test/claimjson.js
            cnf-certification-test/results.html
            cnf-certification-test/tnf-execution.log

      - name: Upload container test results as an artifact
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: smoke-tests-container
          path: |
            ${{ env.TNF_OUTPUT_DIR }}/*.xml
            ${{ env.TNF_OUTPUT_DIR }}/claim.json
            ${{ env.TNF_OUTPUT_DIR }}/claimjson.js
            ${{ env.TNF_OUTPUT_DIR }}/results.html
            ${{ env.TNF_OUTPUT_DIR }}/tnf-execution.log
