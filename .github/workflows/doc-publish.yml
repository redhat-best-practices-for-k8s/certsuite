# documentation publish
---
name: doc-publish
on:
  push:
    branches:
      - master
      - main
permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-24.04
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      
      - name: Setup Node.js for dashboard generation
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: Generate nightlies dashboard
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Generating nightlies dashboard data..."
          npm init -y
          npm install @octokit/rest
          
          # Create the dashboard generation script
          cat > generate-dashboard.js << 'EOF'
          import { Octokit } from '@octokit/rest';
          import fs from 'fs';
          import path from 'path';
          import { fileURLToPath } from 'url';
          
          const __filename = fileURLToPath(import.meta.url);
          const __dirname = path.dirname(__filename);
          
          const octokit = new Octokit({
            auth: process.env.GITHUB_TOKEN
          });
          
          const REPO_OWNER = 'redhat-best-practices-for-k8s';
          const REPO_NAME = 'certsuite';
          const DAYS_BACK = 3;
          
          // Workflows to monitor (from the rekick script)
          const WORKFLOWS_TO_MONITOR = [
            "QE OCP 4.14 Testing",
            "QE OCP 4.15 Testing", 
            "QE OCP 4.16 Testing",
            "QE OCP 4.17 Testing",
            "QE OCP 4.18 Testing",
            "QE OCP 4.19 Testing",
            "QE OCP 4.14 Intrusive Testing",
            "QE OCP 4.15 Intrusive Testing",
            "QE OCP 4.16 Intrusive Testing", 
            "QE OCP 4.17 Intrusive Testing",
            "QE OCP 4.18 Intrusive Testing",
            "QE OCP 4.19 Intrusive Testing",
            "qe-ocp-hosted.yml"
          ];
          
          async function fetchWorkflowData() {
            console.log('Fetching workflow data...');
            
            // Calculate cutoff date
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - DAYS_BACK);
            
            try {
              // Get all workflows
              const { data: workflows } = await octokit.rest.actions.listRepoWorkflows({
                owner: REPO_OWNER,
                repo: REPO_NAME
              });
              
              const workflowResults = [];
              
              for (const workflowName of WORKFLOWS_TO_MONITOR) {
                console.log(`Processing workflow: ${workflowName}`);
                
                // Find the workflow by name or filename
                const workflow = workflows.workflows.find(w =>
                  w.name === workflowName ||
                  w.path.includes(workflowName) ||
                  w.path.includes(workflowName.toLowerCase().replace(/\s+/g, '-'))
                );
                
                if (!workflow) {
                  console.warn(`Workflow not found: ${workflowName}`);
                  workflowResults.push({
                    workflow: workflowName,
                    runs: [],
                    id: null,
                    error: 'Workflow not found'
                  });
                  continue;
                }
                
                try {
                  // Fetch recent runs for this workflow
                  const { data: runsData } = await octokit.rest.actions.listWorkflowRuns({
                    owner: REPO_OWNER,
                    repo: REPO_NAME,
                    workflow_id: workflow.id,
                    per_page: 30
                  });
                  
                  // Filter runs from last N days
                  const recentRuns = runsData.workflow_runs.filter(run =>
                    new Date(run.created_at) >= cutoffDate
                  );
                  
                  workflowResults.push({
                    workflow: workflowName,
                    runs: recentRuns,
                    id: workflow.id,
                    path: workflow.path
                  });
                  
                } catch (error) {
                  console.error(`Error fetching runs for ${workflowName}:`, error.message);
                  workflowResults.push({
                    workflow: workflowName,
                    runs: [],
                    id: workflow.id,
                    error: error.message
                  });
                }
              }
              
              return workflowResults;
              
            } catch (error) {
              console.error('Error fetching workflows:', error);
              throw error;
            }
          }
          
          async function updateDashboardHTML(workflowResults) {
            console.log('Updating dashboard HTML...');
            
            // Calculate summary stats
            let totalRuns = 0;
            let successfulRuns = 0;
            let failedRuns = 0;
            let pendingRuns = 0;
            let totalDurationMs = 0;
            let completedRuns = 0;
            
            workflowResults.forEach(result => {
              result.runs.forEach(run => {
                totalRuns++;
                switch (run.conclusion) {
                  case 'success':
                    successfulRuns++;
                    break;
                  case 'failure':
                  case 'timed_out':
                    failedRuns++;
                    break;
                  default:
                    pendingRuns++;
                }
                
                // Calculate duration for completed runs
                if (run.conclusion && run.created_at && run.updated_at) {
                  const duration = new Date(run.updated_at) - new Date(run.created_at);
                  totalDurationMs += duration;
                  completedRuns++;
                }
              });
            });
            
            const successRate = totalRuns > 0 ? Math.round((successfulRuns / totalRuns) * 100) : 0;
            
            // Helper function to format duration
            function formatDuration(durationMs) {
              const hours = Math.floor(durationMs / (1000 * 60 * 60));
              const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
              
              if (hours > 0) {
                return hours + 'h' + (minutes > 0 ? ' ' + minutes + 'm' : '');
              } else {
                return minutes + 'm';
              }
            }
            
            const avgRuntime = completedRuns > 0 ? formatDuration(totalDurationMs / completedRuns) : '0h';
            const lastUpdated = new Date().toISOString();
            
            // Read the template HTML
            const templatePath = path.join(__dirname, 'docs/nightlies/index.html');
            let html = fs.readFileSync(templatePath, 'utf8');
            
            // Replace the JavaScript data loading with pre-populated data
            const dataScript = `
              <script>
                // Pre-generated data from GitHub Actions
                const WORKFLOW_DATA = ${JSON.stringify(workflowResults, null, 2)};
                const SUMMARY_STATS = {
                  totalRuns: ${totalRuns},
                  successfulRuns: ${successfulRuns},
                  failedRuns: ${failedRuns},
                  pendingRuns: ${pendingRuns},
                  successRate: ${successRate},
                  avgRuntime: '${avgRuntime}'
                };
                const LAST_UPDATED = '${lastUpdated}';
          
                // Helper functions (same as before)
                function getStatusClass(conclusion) {
                  switch (conclusion) {
                    case 'success': return 'success';
                    case 'failure':
                    case 'timed_out': return 'failure';
                    default: return 'pending';
                  }
                }
          
                function formatDuration(durationMs) {
                  const hours = Math.floor(durationMs / (1000 * 60 * 60));
                  const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
          
                  if (hours > 0) {
                    return hours + 'h ' + minutes + 'm';
                  } else {
                    return minutes + 'm';
                  }
                }
          
                function getTimeAgo(date) {
                  const now = new Date();
                  const diffMs = now - new Date(date);
                  const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                  const diffDays = Math.floor(diffHours / 24);
          
                  if (diffDays > 0) {
                    return diffDays + ' day' + (diffDays > 1 ? 's' : '') + ' ago';
                  } else if (diffHours > 0) {
                    return diffHours + ' hour' + (diffHours > 1 ? 's' : '') + ' ago';
                  } else {
                    const diffMinutes = Math.floor(diffMs / (1000 * 60));
                    return diffMinutes + ' minute' + (diffMinutes > 1 ? 's' : '') + ' ago';
                  }
                }
          
                // Load pre-generated data instead of fetching from API
                document.addEventListener('DOMContentLoaded', function() {
                  // Hide loading, show content
                  document.getElementById('loading').style.display = 'none';
                  document.getElementById('workflows').style.display = 'grid';
          
                  // Generate summary
                  document.getElementById('summary').innerHTML = \`
                    <div class="card success">
                      <h3>Success Rate</h3>
                      <div class="value">\${SUMMARY_STATS.successRate}%</div>
                      <div>\${SUMMARY_STATS.successfulRuns}/\${SUMMARY_STATS.totalRuns} runs</div>
                    </div>
                    <div class="card failure">
                      <h3>Failed Runs</h3>
                      <div class="value">\${SUMMARY_STATS.failedRuns}</div>
                      <div>Last 3 days</div>
                    </div>
                    <div class="card pending">
                      <h3>Active Workflows</h3>
                      <div class="value">\${WORKFLOW_DATA.length}</div>
                      <div>Being monitored</div>
                    </div>
                    <div class="card">
                      <h3>Avg Runtime</h3>
                      <div class="value">\${SUMMARY_STATS.avgRuntime}</div>
                      <div>Completed runs</div>
                    </div>
                  \`;
          
                  // Helper function for formatting duration in the generated JS
                  function formatDurationInJS(durationMs) {
                    const hours = Math.floor(durationMs / (1000 * 60 * 60));
                    const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
          
                    if (hours > 0) {
                      return hours + 'h ' + minutes + 'm';
                    } else {
                      return minutes + 'm';
                    }
                  }
          
                  // Generate workflow cards
                  const workflowsHtml = WORKFLOW_DATA.map(result => {
                    const runsHtml = result.runs.slice(0, 10).map(run => {
                      const statusClass = getStatusClass(run.conclusion);
                      const runUrl = run.html_url;
                      const timeAgo = getTimeAgo(run.created_at);
          
                      // Calculate duration
                      let durationText = '';
                      if (run.conclusion && run.created_at && run.updated_at) {
                        const duration = new Date(run.updated_at) - new Date(run.created_at);
                        durationText = ' • ' + formatDurationInJS(duration) + ' duration';
                      } else if (!run.conclusion && run.created_at) {
                        // For running jobs, show elapsed time
                        const elapsed = new Date() - new Date(run.created_at);
                        durationText = ' • ' + formatDurationInJS(elapsed) + ' elapsed';
                      }
          
                      return \`
                        <div class="run-item">
                          <div class="status-badge \${statusClass}"></div>
                          <div class="run-info">
                            <a href="\${runUrl}" class="run-id" target="_blank">
                              #\${run.run_number} - \${run.conclusion || 'running'}
                            </a>
                            <div class="run-time">\${timeAgo}\${durationText}</div>
                          </div>
                        </div>
                      \`;
                    }).join('');
          
                    const successCount = result.runs.filter(r => r.conclusion === 'success').length;
                    const totalCount = result.runs.length;
          
                    // Calculate average runtime for this workflow
                    const completedRuns = result.runs.filter(r => r.conclusion && r.created_at && r.updated_at);
                    let avgWorkflowRuntime = '';
                    if (completedRuns.length > 0) {
                      const totalMs = completedRuns.reduce((sum, run) => {
                        return sum + (new Date(run.updated_at) - new Date(run.created_at));
                      }, 0);
                      avgWorkflowRuntime = ' • avg ' + formatDurationInJS(totalMs / completedRuns.length);
                    }
          
                    // Generate workflow URL
                    const workflowUrl = result.path ?
                      \`https://github.com/redhat-best-practices-for-k8s/certsuite/actions/workflows/\${result.path.split('/').pop()}\` :
                      \`https://github.com/redhat-best-practices-for-k8s/certsuite/actions\`;
          
                    return \`
                      <div class="workflow-card">
                        <div class="workflow-header">
                          <div>
                            <a href="\${workflowUrl}" class="workflow-title-link" target="_blank">
                              <div class="workflow-title">\${result.workflow}</div>
                            </a>
                            <div class="workflow-subtitle">
                              \${totalCount} runs in last 3 days
                              (\${successCount} successful)\${avgWorkflowRuntime}
                            </div>
                          </div>
                        </div>
                        <div class="runs-list">
                          \${runsHtml || '<div class="run-item">No recent runs</div>'}
                        </div>
                      </div>
                    \`;
                  }).join('');
          
                  document.getElementById('workflows').innerHTML = workflowsHtml;
          
                  // Update last updated time
                  document.getElementById('last-updated').innerHTML =
                    'Last updated: ' + new Date(LAST_UPDATED).toLocaleString();
                });
          
                function refreshData() {
                  window.location.reload();
                }
              </script>
            `;
            
            // Add CSS for workflow title links before replacing the script
            const linkCSS = `
            .workflow-title-link {
                text-decoration: none;
                color: inherit;
            }
            
            .workflow-title-link:hover .workflow-title {
                color: #3b82f6;
                text-decoration: underline;
            }`;
            
            // Insert the new CSS before the closing </style> tag
            html = html.replace('</style>', linkCSS + '\\n        </style>');
            
            // Replace the existing script tag with our data script
            html = html.replace(/<script>[\s\S]*?<\/script>/, dataScript);
            
            // Write the updated HTML back to the template
            fs.writeFileSync(templatePath, html);
            
            console.log('Dashboard updated successfully!');
            console.log(`Updated at: ${new Date().toISOString()}`);
            
            // Also save the raw data for debugging
            fs.writeFileSync(
              path.join(__dirname, 'docs/nightlies/workflow-data.json'),
              JSON.stringify(workflowResults, null, 2)
            );
          }
          
          async function main() {
            try {
              const workflowResults = await fetchWorkflowData();
              await updateDashboardHTML(workflowResults);
              console.log('Dashboard generation completed successfully!');
            } catch (error) {
              console.error('Error updating dashboard:', error);
              // Don't fail the build if dashboard generation fails
              console.log('Continuing with site build despite dashboard error...');
            }
          }
          
          main();
          EOF
          
          # Set package.json to ES module mode
          echo '{"type": "module"}' > package.json
          
          # Generate the dashboard
          node generate-dashboard.js
      
      - name: generate site
        uses: ./.github/actions/documentation

      - name: Deploy
        uses: peaceiris/actions-gh-pages@4f9cc6602d3f66b9c108549d475ec49e8ef4d45e # v4.0.0
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./site
